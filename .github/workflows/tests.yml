name: Tests

on:
  workflow_dispatch:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  install_poetry:
   runs-on: ubuntu-latest
   steps:
     - uses: actions/checkout@v2

     - name: Check poetry lockfile exists
       run: "test -f poetry.lock || (echo No lock file! && false)"
       shell: bash

     - uses: actions/setup-python@v4
       with:
         python-version: "3.x"

#     - name: Restore/cache poetry installation
#       id: poetry-install-cache
#       uses: actions/cache@v2
#       with:
#         path: ${{ steps.site-user-base.outputs.dir }}
#         key: poetry-install-cache-${{ steps.setup-python.outputs.python-version }}-${{ inputs.poetry-version }}

     - name: Install poetry from scratch
#       if: "${{ steps.poetry-install-cache.outputs.cache-hit != 'true' }}"
       run: pipx install poetry==1.2.0
       shell: bash

     # Poetry manages a virtualenv for us. We're going to cache that too.
     # Again, we're following snok/install-poetry's README.
#     - name: Locate poetry venv
#       id: poetry-venvs
#       run: echo "::set-output name=dir::$(python -m poetry config virtualenvs.path)"
#       shell: bash
#
#     - name: Restore/cache poetry venv
#       id: poetry-venv-cache
#       uses: actions/cache@v2
#       with:
#         path: ${{ steps.poetry-venvs.outputs.dir }}
#         key: poetry-venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}-${{ inputs.extras }}

     - name: Check that the poetry lockfile is up to date
       run: poetry lock --check
       shell: bash

     - name: Install project
       run: poetry install --no-interaction
       shell: bash

     # For debugging---let's just check what we're working with.
     - name: Dump virtual environment
       run: |
         poetry env info
         poetry run pip list
       shell: bash

